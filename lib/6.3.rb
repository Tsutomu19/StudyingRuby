/正規表現/

regex = /|d{3}-\d{4}/
regex.class
正規表現はRegexpクラスのオブジェクトになります。


regex = /\d{3}-\d{4}/

'123-4567'=~ /\d{3}-\d{4}/
# =>0
'hello' =~ /\d{3}-\d{4}/
# => nil

if '123-4567' =~ /\d{3}-\d{4}/
    puts 'マッチしました'
else
    puts'マッチしませんでした'
end

また、=~は文字列と正規表現を入れ替えても同じ結果になります(ただし例外ある)


/\d{3}-\d{4}/ =~ '123-4567'
/\d{3}-\d{4}/ =~ 'hello'

!~を使うとマッチしなかった時にtrueをマッチした時にfalseを返します

'hello'!~/\d{3}-\d{4}/

6.3.1 Rubularで視覚的にマッチする文字列を確認する

正規表現が得意な人でも試行錯誤することがある。
そんなんときは正規表現にマッチする文字列を視覚的に確認できるオンラインツールを使うと便利です。

+は直前の文字が一個以上



私の電話番号は090-8908-8879です


\dは半角数字一文字を表す


6.3.2 正規表現のキャプチャを利用する

私の誕生日は1977年7月17日です。

この中の数字を取り出す



\d+年\d＋月\d+日
このままだと1977年7月17日という一続きの文字列にマッチしたことになります
さらに年と月とひを分解する必要が
ある。

こんな時は正規表現のキャプチャ機能を使うと便利です
キャプチャは()を追加って抜き出したい部分を指定


(\d+)年(\d+)月(\d+)日


Match groups:

1.	1977
2.	7
3.	17

rubyでも同じことができる



text ='私の誕生日は1977年7月17日です。'
m = /(\d+)年(\d+)月(\d+)日/.match(text)
m[1]
m[2]
m[3]
上記のコードのようにキャプチャを活用する方法の一つはmatchメソッドを使うことです
文字列が正規表現にマッチするとmatchDataオブジェクトが帰ります。マッチしない場合はnilがカエル







/(\d+)年(\d+)月(\d+)日/.match(text)
/(\d+)年(\d+)月(\d+)日/.match('foo')

この性質を使って、条件分岐のなかで真偽値の判定とローカル変数への代入を同時にやってしまうコードがよく使われます



text = '私の誕生日は1977年7月17日です。'
if m = /(\d+)年(\d+)月(\d+)日/.match(text)
    マッチした場合の処理
else
    マッチしなかった場合の処理
end


MatchDataは[]を使って正規表現の処理結果を配列と同じような方法で取得できます

text = '私の誕生日は1977年7月17日です'
m = /(\d+)年(\d+)月(\d+)日/.match(text)
# マッチした部分全体を取得する
n[0]
# キャプチャの一番めを取得する
m[1]
# キャプチャの2番目から二個取得する
m[2,2]
# 最後のキャプチャを取得する
m[-1]
# rangeを使って取得する
m[1..3]

なおmatchメソッドはStringクラスとRegexpクラスの両方に定義されているため、文字列と正規表現オブジェクトを入れ替えtも同じように動作します。


text = '私の誕生日は1977年7月17日です。'
m = text.match(/(\d+)年(\d+)月(\d+)日/)




6.3.3　キャプチャの結果に名前をつける

さて、キャプチャはこのままでも便利なのですが、結果を連番で取得する必要があるため

何番目が何の値かということをプログラマが意識しなくてはいけません。そこで
キャプチャには(?<name>)というメタ文字を使って名前をtけることができます
例えば先ほどの正規表現を次のように変えてみましょう。

(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日

こうすると連番ではなく名前でキャプチャの結果を取得することができるため、
何番目が何の値かということを気にしなくてよくなる




text =  '私の誕生日は1977年7月17日です。'
m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)

m[:year] =>1977
m[:month] =>7
m[:day] =>17

m['year']

m[2]

名前つきキャプチャを使った正規表現にはもう一つの機能があります。
それは左辺にせ式表現リテラルを右辺に文字列を置いて=~演算子を使うと
キャプチャの名前がそのままローカル変数に割り当てられる




text =  '私の誕生日は1977年7月17日です'
キャプチャの名前がそのままローカル変数に割り当てられる
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+日)/ =~ text
    puts "#{year}/#{month}/#{day}"
end

=>1977/7/17



text =  '私の誕生日は1977年7月17日です'
if text =~ /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/
    puts "#{year}/#{month}/#{day}"
end

また正規表現オブジェクトを一旦変数に入れたりした場合も使えないので注意してください


text =  '私の誕生日は1977年7月17日です。'
regexp = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/

if regexp =~text
    puts"#{year}/#{month}/#{day}"
end




6.3.4 正規表現と組み合わせると便利なStringクラスのメソッド

Stringクラスのメソッド
Stiringクラスには正規表現と組み合わせると便利に使えるメソッドがいくつか用意されています。
ここからは以下のメソッドについて詳しく説明して行きます

・scan
・[],slice,slice!
・split
・gsub,gsub!


scan
scanメソッドは引数で渡した正規表現にマッチする部分を配列に入れて返します。
'123 456 789'.scan(/\d+/)
正規表現に()があると、キャプチャされた部分が配列の配列になって返ってきます


'1977年7月17日　2016年12月31日'.scan(/(\d+)年(\d+)月(\d+)日/)
# =>[["1977","7","17"],["2016","12","31"]]

グループ化はしたいが、キャプチャはしたくないという場合は(?:)というメタ文字を使ってください

'1977年7月17日　2016年12月31日'.scan(/(?:\d+)年(?:\d+)月(?:\d+)日/)


より簡潔に
'1977年7月17日　2016年12月31日'.scan(/\d+年\d+月\d+日/)





[],slice,slice!
[]に正規表現を渡すと、文字列から正規表現に亜mt血した部分を抜き出す

text = '郵便番号は123-4566です'
text[/\d{3}-\d{4}/]

マッチする部分が複数ある場合は、最初にマッチした文字列が返ります。
text = '123-4567 456-7890'
text[/\d{3}-\d{4}]
# =>123-4567

text = '誕生日は1977年7月17日です'

text[/(d+)年(\d+)月(\d+)日/]

text[/(d+)年(\d+)月(\d+)日/,3]
# =>17


名前つきキャプチャであれば名前で指定することもできます

text = '誕生日は1977年7月17日です'

text[/(?<year>\d)年(?<month>\d+)月(?<day>\d+)日/,:day]
# =>17

text[/(?<year>\d)年(?<month>\d+)月(?<day>\d+)日/,'day']
# =>17



sliceメソッドは[]のエイリアスメソッドです。
text = '郵便番号は123-4566です'
text.slice(/\d{3}-\d{4}/)

text = '誕生日は1977年7月17日です'
text.slice(/(\d+)年(\d+)月(\d+)日/,3)


破壊的
text = '郵便番号は123-4567です'
text.slice!(/\d{3}-\d[4]/)
text



gsubメソッドを使うと、第一引数の正規表現にマッチした文字列を第二引数の文字列で置き換えます


text = '123,456-789'
text.gsub(',',':')
# =>123:456-789

text.gsub(/,|-/,':')
# =>123:456:789


# 第二引数にハッシュをわたして、変換のルールを指定することもできます
text = '123,456-789'
hash = {','=>':','-'=>'/'}
text.gsub(/,|-/,hash)
# 第二引数を渡す代わりに、ブロック位の戻り値で置き換える文字列を指定することもできます
text.gsub(/,|-/){|matched|matchd == ','?':':'/'}
=> "123:456/789"



















